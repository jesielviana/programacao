{"componentChunkName":"component---src-templates-markdown-js","path":"/lectures/14s","result":{"data":{"markdownRemark":{"html":"<p>class: center, middle, block-text</p>\n<h1>Lecture 14</h1>\n<h2>Web Assembly</h2>\n<hr>\n<p>class: center, middle, block-text</p>\n<h1>Logistics</h1>\n<hr>\n<p>class: med-large</p>\n<h1>WASM</h1>\n<ul>\n<li>run programming languages outside of JS in the web browser</li>\n<li>can use it in parallel with JS</li>\n</ul>\n<hr>\n<p>class: center, middle, block-text</p>\n<h1>JS isn't fast</h1>\n<hr>\n<p>class: large</p>\n<h3>Browser Wars</h3>\n<p>So from 1995-2008 everything was pretty slow in browsers</p>\n<img src=\"https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/02/01-01-perf_graph05.png\" height=\"400\">\n<hr>\n<p>class: large</p>\n<h2>JS is now used for things</h2>\n<ul>\n<li>Node.js => only reason it is  a thing is because of Chrome developing a JS engine that uses a JIT</li>\n</ul>\n<hr>\n<p>class: x-large</p>\n<h2>But step back</h2>\n<ul>\n<li>\n<p>what happens to the code you put on a webpage in JS?</p>\n<ul>\n<li>parse</li>\n<li>compiling + optimization</li>\n<li>reoptimization</li>\n<li>execution</li>\n<li>garbage collection</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>class: large</p>\n<h1>But if we were to use webassembly...</h1>\n<p>We skip some steps because things are compiled for us already!</p>\n<p>So now its just</p>\n<ul>\n<li>decode</li>\n<li>compile + optimize</li>\n<li>execute</li>\n</ul>\n<hr>\n<p>class: large</p>\n<h2>But what does the JIT do?</h2>\n<ul>\n<li>disconnect between JS and 1s and 0s.</li>\n<li>interpreters vs compilers</li>\n</ul>\n<img src=\"https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/02/02-01-alien03.png\" height=\"300px\">\n<hr>\n<p>class: med-large</p>\n<h2>In the Browser what do we want?</h2>\n<ul>\n<li>Initially browsers employed interpreters to execute JS code</li>\n<li>\n<p>slow behavior</p>\n<ul>\n<li>\n<p>Introduction of a \"Monitor\" and early compilers in browsers:</p>\n<ul>\n<li>Warm Functions</li>\n<li>Stubs &#x26; the baseline compiler</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>class: large</p>\n<h2>No Guarantees</h2>\n<ul>\n<li>compiled code does a check to make sure things fit the assumptions it has made</li>\n<li>if not -> deoptimize/bail out and throw away optimized compiled code</li>\n<li>\n<p>usually these optimizing compilers will make code quicker</p>\n<ul>\n<li>but scenario of code that is hot (but repetitively enters cycle of getting hot -> bailing out) will take <em>longer</em> than usual to execute.</li>\n<li>\n<h2>JITs will keep track of this and prevent bail outs</h2>\n</li>\n</ul>\n</li>\n</ul>\n<p>class: large</p>\n<h2>How do we make things faster?</h2>\n<ul>\n<li>\n<p>get rid of dynamic types</p>\n<ul>\n<li>but thats what makes js so great</li>\n</ul>\n</li>\n<li>we don't  need to change things in JS!</li>\n</ul>\n<p>I'm very excited about the \"Internet of Things.\"</p>\n<hr>\n<p>class: large</p>\n<h2>Assembly Crash Course</h2>\n<ul>\n<li>ALU = arithmetic + logic unit</li>\n<li>short term memory = registrars</li>\n<li>longer term = random access memory</li>\n<li>ALU + registers = CPU</li>\n</ul>\n<hr>\n<p>class: large</p>\n<h2>Steps</h2>\n<ul>\n<li>so we can go from C -> Intermediate representation -> Wasm -> x86/ARM</li>\n<li>The step from C -> IR (refered to as the \"front end\") can be done via tools like clang/gcc.</li>\n<li>From there, we can use emscripten to go from IR -> wasm</li>\n<li>We eventually get .wasm</li>\n<li>Let's say you're calling a wasm function from JS. wasm functions can only take in wasm types as parameters (right now its just numbers)</li>\n</ul>\n<hr>\n<p>class: med-large</p>\n<h1>Okay so why is wasm faster?</h1>\n<ul>\n<li>its a bit more compact</li>\n<li>parsing takes less time</li>\n<li>normally JS -> interpreter -> AST -> bytecode</li>\n<li>but wasm is already in bytecode! just needs to be decoded (which is quick)</li>\n<li>compiling takes a lot less time bc its done ahead of time</li>\n<li>no bail outs</li>\n<li>10-800% faster</li>\n<li>garbage collection is manual though :/</li>\n<li>\n<p>you can use it!</p>\n<ul>\n<li>asm for older browser (its just JS)</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>class: med-large</p>\n<h2>Examples</h2>\n<p><a href=\"https://websightjs.com/\">https://websightjs.com/</a></p>\n<p><a href=\"https://wasdk.github.io/WasmFiddle/?uhvxz\">https://wasdk.github.io/WasmFiddle/?uhvxz</a></p>","frontmatter":{"date":"January 29, 2019","path":"/lectures/14s","title":"Web Assembly","metaTitle":null}}},"pageContext":{}}}